#!/usr/bin/bash

# --- Colors for formatting ---
BOLD="\033[1m"
UNDERLINE="\033[4m"
RESET="\033[0m"

BLACK="\033[30m"
BOLDBLACK="$BOLD$BLACK"
RED="\033[31m"
BOLDRED="$BOLD$RED"
GREEN="\033[32m"
BOLDGREEN="$BOLD$GREEN"
YELLOW="\033[33m"
BOLDYELLOW="$BOLD$YELLOW"
BLUE="\033[34m"
BOLDBLUE="$BOLD$BLUE"
MAGENTA="\033[35m"
BOLDMAGENTA="$BOLDA$MAGENTA"
CYAN="\033[36m"
BOLDCYAN="$BOLD$CYAN"
WHITE="\033[36m"
BOLDWHITE="$BOLD$WHITE"

# Function: move_cursor <row> <col>
# move_cursor 2 10
move_cursor() {
    local row=$1
    local col=$2
    printf "\033[${row};${col}H"
}

# Move to bottom to prevent prompt from overwriting the UI
move_cursor 10 1
# Get terminal dimensions
# WIDTH=$(tput cols)
# HEIGHT=$(tput lines)
WIDTH=$(tput cols < /dev/tty)
HEIGHT=$(tput lines < /dev/tty)

# Calculate horizontal midpoint and prompt position
START_COL=$((WIDTH / 2))
PROMPT_ROW=$((HEIGHT - 4))
PROMPT_COLUMN=$((0 + 4))
MSG_ROW=$((HEIGHT - 2))
MSG_COLUMN=$((0 + 4))

START_ROW=1
REMROW=$START_ROW
REMCOL=$START_COL

if [ -f ".posirow" ]; then
    START_ROW=$(cat .posirow)
    REMROW=$START_ROW
fi
if [ -f ".posicol" ]; then
    START_COL=$(cat .posicol)
    REMCOL=$START_COL
fi


while getopts "hxc:r:tpm:" arg
do
    case $arg in
        h) usage
           ;;
        x) clear
           START_ROW=1
           REMROW=$START_ROW
           echo $REMROW > .posirow

           START_COL=2
           REMCOL=$START_COL
           echo $REMCOL > .posicol

           printf "\033[${START_ROW};1H"
           printf "\033[${START_COL}G"
           exit 0
           ;;
        c) START_COL=$OPTARG
           REMCOL=$START_COL
           ;;
        t) START_ROW=1
           REMROW=$START_ROW
           echo $REMROW > .posirow
           printf "\033[${START_ROW};1H"
           exit 0
           ;;
        r) START_ROW=$OPTARG
           REMROW=$START_ROW
           ;;
        p) START_ROW=$(cat .posirow)
           START_COL=$(cat .posicol)
           REMROW=$START_ROW
           REMCOL=$START_COL
           ;;
        m) line=$OPTARG
           printf "\033[${MSG_ROW};1H"
           printf "\033[${MSG_COL}G\033[K%s" 
           echo -e "$MAGENTA$line$RESET"

           exit 0
           ;;
    esac
done
shift $(($OPTIND - 1))


if [ "$#" -gt 0 ]; then
    INPUT_SOURCE="$1"
else
    INPUT_SOURCE="/dev/stdin"
fi



# Begin

# Move cursor to the specific Start Row, Column 1 to begin printing
printf "\033[${START_ROW};1H"

# Read file and print
if [[ "$INPUT_SOURCE" = "/dev/stdin" ]]; then                                                                                               
    cat  "$INPUT_SOURCE" | while IFS= read -r line || [ -n "$line" ]; do
        # \033[nG -> Move to midpoint
        # \033[K  -> Clear to end of line
        # %s      -> Print line content
        # \n      -> Move down
        #printf "\033[${START_COL}G\033[K%s\n"  "$line"
        printf "\033[${START_COL}G%s\n"  "$line"
        REMROW=$((REMROW + 1))
        echo $REMROW > .posirow
        echo $REMCOL > .posicol
    done
else
    echo "$INPUT_SOURCE" | while IFS= read -r line || [ -n "$line" ]; do
        #printf "\033[${START_COL}G\033[K%s\n"  "$line"
        printf "\033[${START_COL}G%s\n"  "$line"
        REMROW=$((REMROW + 1))
        echo $REMROW > .posirow
        echo $REMCOL > .posicol
    done
fi


# Move cursor to the second-to-last line for the prompt
#printf "\033[${PROMPT_ROW};1H"
